"use strict";
var path = require('path');
var ts = require('typescript');
var plugin_1 = require('./plugin');
var refactor_1 = require('./refactor');
var loaderUtils = require('loader-utils');
var NormalModule = require('webpack/lib/NormalModule');
function _getContentOfKeyLiteral(source, node) {
    if (node.kind == ts.SyntaxKind.Identifier) {
        return node.text;
    }
    else if (node.kind == ts.SyntaxKind.StringLiteral) {
        return node.text;
    }
    else {
        return null;
    }
}
function _angularImportsFromNode(node, sourceFile) {
    var ms = node.moduleSpecifier;
    var modulePath = null;
    switch (ms.kind) {
        case ts.SyntaxKind.StringLiteral:
            modulePath = ms.text;
            break;
        default:
            return [];
    }
    if (!modulePath.startsWith('@angular/')) {
        return [];
    }
    if (node.importClause) {
        if (node.importClause.name) {
            // This is of the form `import Name from 'path'`. Ignore.
            return [];
        }
        else if (node.importClause.namedBindings) {
            var nb = node.importClause.namedBindings;
            if (nb.kind == ts.SyntaxKind.NamespaceImport) {
                // This is of the form `import * as name from 'path'`. Return `name.`.
                return [nb.name.text + '.'];
            }
            else {
                // This is of the form `import {a,b,c} from 'path'`
                var namedImports = nb;
                return namedImports.elements
                    .map(function (is) { return is.propertyName ? is.propertyName.text : is.name.text; });
            }
        }
    }
    else {
        // This is of the form `import 'path';`. Nothing to do.
        return [];
    }
}
function _ctorParameterFromTypeReference(paramNode, angularImports, refactor) {
    if (paramNode.type.kind == ts.SyntaxKind.TypeReference) {
        var type = paramNode.type;
        var decorators = refactor.findAstNodes(paramNode, ts.SyntaxKind.Decorator);
        var decoratorStr = decorators
            .map(function (decorator) {
            var fnName = refactor.findFirstAstNode(decorator, ts.SyntaxKind.CallExpression)
                .expression.getText(refactor.sourceFile);
            if (angularImports.indexOf(fnName) === -1) {
                return null;
            }
            else {
                return fnName;
            }
        })
            .filter(function (x) { return !!x; })
            .map(function (name) { return ("{ type: " + name + " }"); })
            .join(', ');
        if (type.typeName.kind == ts.SyntaxKind.Identifier) {
            var typeName = type.typeName;
            if (decorators.length > 0) {
                return "{ type: " + typeName.text + ", decorators: [" + decoratorStr + "] }";
            }
            return "{ type: " + typeName.text + " }";
        }
    }
    return 'null';
}
function _addCtorParameters(classNode, angularImports, refactor) {
    // For every classes with constructors, output the ctorParameters function which contains a list
    // of injectable types.
    var ctor = refactor.findFirstAstNode(classNode, ts.SyntaxKind.Constructor);
    if (!ctor) {
        // A class can be missing a constructor, and that's _okay_.
        return;
    }
    var params = Array.from(ctor.parameters).map(function (paramNode) {
        switch (paramNode.type.kind) {
            case ts.SyntaxKind.TypeReference:
                return _ctorParameterFromTypeReference(paramNode, angularImports, refactor);
            default:
                return 'null';
        }
    });
    var ctorParametersDecl = "static ctorParameters() { return [ " + params.join(', ') + " ]; }";
    refactor.prependBefore(classNode.getLastToken(refactor.sourceFile), ctorParametersDecl);
}
function _removeDecorators(refactor) {
    var angularImports = refactor.findAstNodes(refactor.sourceFile, ts.SyntaxKind.ImportDeclaration)
        .map(function (node) { return _angularImportsFromNode(node, refactor.sourceFile); })
        .reduce(function (acc, current) { return acc.concat(current); }, []);
    // Find all decorators.
    refactor.findAstNodes(refactor.sourceFile, ts.SyntaxKind.Decorator)
        .forEach(function (node) {
        // First, add decorators to classes to the classes array.
        if (node.parent) {
            var declarations = refactor.findAstNodes(node.parent, ts.SyntaxKind.ClassDeclaration, false, 1);
            if (declarations.length > 0) {
                _addCtorParameters(declarations[0], angularImports, refactor);
            }
        }
        refactor.findAstNodes(node, ts.SyntaxKind.CallExpression)
            .filter(function (node) {
            var fnName = node.expression.getText(refactor.sourceFile);
            if (fnName.indexOf('.') != -1) {
                // Since this is `a.b`, see if it's the same namespace as a namespace import.
                return angularImports.indexOf(fnName.replace(/\..*$/, '') + '.') != -1;
            }
            else {
                return angularImports.indexOf(fnName) != -1;
            }
        })
            .forEach(function () { return refactor.removeNode(node); });
    });
}
function _replaceBootstrap(plugin, refactor) {
    // If bootstrapModule can't be found, bail out early.
    if (!refactor.sourceMatch(/\bbootstrapModule\b/)) {
        return;
    }
    // Calculate the base path.
    var basePath = path.normalize(plugin.basePath);
    var genDir = path.normalize(plugin.genDir);
    var dirName = path.normalize(path.dirname(refactor.fileName));
    var entryModule = plugin.entryModule;
    var entryModuleFileName = path.normalize(entryModule.path + '.ngfactory');
    var relativeEntryModulePath = path.relative(basePath, entryModuleFileName);
    var fullEntryModulePath = path.resolve(genDir, relativeEntryModulePath);
    var relativeNgFactoryPath = path.relative(dirName, fullEntryModulePath);
    var ngFactoryPath = './' + relativeNgFactoryPath.replace(/\\/g, '/');
    var allCalls = refactor.findAstNodes(refactor.sourceFile, ts.SyntaxKind.CallExpression, true);
    var bootstraps = allCalls
        .filter(function (call) { return call.expression.kind == ts.SyntaxKind.PropertyAccessExpression; })
        .map(function (call) { return call.expression; })
        .filter(function (access) {
        return access.name.kind == ts.SyntaxKind.Identifier
            && access.name.text == 'bootstrapModule';
    });
    var calls = bootstraps
        .reduce(function (previous, access) {
        var expressions = refactor.findAstNodes(access, ts.SyntaxKind.CallExpression, true);
        return previous.concat(expressions);
    }, [])
        .filter(function (call) {
        return call.expression.kind == ts.SyntaxKind.Identifier
            && call.expression.text == 'platformBrowserDynamic';
    });
    if (calls.length == 0) {
        // Didn't find any dynamic bootstrapping going on.
        return;
    }
    // Create the changes we need.
    allCalls
        .filter(function (call) { return bootstraps.some(function (bs) { return bs == call.expression; }); })
        .forEach(function (call) {
        refactor.replaceNode(call.arguments[0], entryModule.className + 'NgFactory');
    });
    calls.forEach(function (call) { return refactor.replaceNode(call.expression, 'platformBrowser'); });
    bootstraps
        .forEach(function (bs) {
        // This changes the call.
        refactor.replaceNode(bs.name, 'bootstrapModuleFactory');
    });
    refactor.insertImport('platformBrowser', '@angular/platform-browser');
    refactor.insertImport(entryModule.className + 'NgFactory', ngFactoryPath);
}
function removeModuleIdOnlyForTesting(refactor) {
    _removeModuleId(refactor);
}
exports.removeModuleIdOnlyForTesting = removeModuleIdOnlyForTesting;
function _removeModuleId(refactor) {
    var sourceFile = refactor.sourceFile;
    refactor.findAstNodes(sourceFile, ts.SyntaxKind.ObjectLiteralExpression, true)
        .filter(function (node) {
        return node.properties.some(function (prop) { return _getContentOfKeyLiteral(sourceFile, prop.name) == 'moduleId'; });
    })
        .forEach(function (node) {
        var moduleIdProp = node.properties.filter(function (prop, idx) {
            return _getContentOfKeyLiteral(sourceFile, prop.name) == 'moduleId';
        })[0];
        // get the trailing comma
        var moduleIdCommaProp = moduleIdProp.parent.getChildAt(1).getChildren()[1];
        refactor.removeNodes(moduleIdProp, moduleIdCommaProp);
    });
}
function _getResourceRequest(element, sourceFile) {
    if (element.kind == ts.SyntaxKind.StringLiteral) {
        // if string, assume relative path unless it start with /
        return "'" + loaderUtils.urlToRequest(element.text, '') + "'";
    }
    else {
        // if not string, just use expression directly
        return element.getFullText(sourceFile);
    }
}
function _replaceResources(refactor) {
    var sourceFile = refactor.sourceFile;
    // Find all object literals.
    refactor.findAstNodes(sourceFile, ts.SyntaxKind.ObjectLiteralExpression, true)
        .map(function (node) { return refactor.findAstNodes(node, ts.SyntaxKind.PropertyAssignment); })
        .reduce(function (prev, curr) { return curr ? prev.concat(curr) : prev; }, [])
        .filter(function (node) {
        var key = _getContentOfKeyLiteral(sourceFile, node.name);
        if (!key) {
            // key is an expression, can't do anything.
            return false;
        }
        return key == 'templateUrl' || key == 'styleUrls';
    })
        .forEach(function (node) {
        var key = _getContentOfKeyLiteral(sourceFile, node.name);
        if (key == 'templateUrl') {
            refactor.replaceNode(node, "template: require(" + _getResourceRequest(node.initializer, sourceFile) + ")");
        }
        else if (key == 'styleUrls') {
            var arr = (refactor.findAstNodes(node, ts.SyntaxKind.ArrayLiteralExpression, false));
            if (!arr || arr.length == 0 || arr[0].elements.length == 0) {
                return;
            }
            var initializer = arr[0].elements.map(function (element) {
                return _getResourceRequest(element, sourceFile);
            });
            refactor.replaceNode(node, "styles: [require(" + initializer.join('), require(') + ")]");
        }
    });
}
function _checkDiagnostics(refactor) {
    var diagnostics = refactor.getDiagnostics();
    if (diagnostics.length > 0) {
        var message = diagnostics
            .map(function (diagnostic) {
            var _a = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start), line = _a.line, character = _a.character;
            var message = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n');
            return diagnostic.file.fileName + " (" + (line + 1) + "," + (character + 1) + "): " + message + ")";
        })
            .join('\n');
        throw new Error(message);
    }
}
/**
 * Recursively calls diagnose on the plugins for all the reverse dependencies.
 * @private
 */
function _diagnoseDeps(reasons, plugin, checked) {
    reasons
        .filter(function (reason) { return reason && reason.module && reason.module instanceof NormalModule; })
        .filter(function (reason) { return !checked.has(reason.module.resource); })
        .forEach(function (reason) {
        checked.add(reason.module.resource);
        plugin.diagnose(reason.module.resource);
        _diagnoseDeps(reason.module.reasons, plugin, checked);
    });
}
// Super simple TS transpiler loader for testing / isolated usage. does not type check!
function ngcLoader() {
    var _this = this;
    var cb = this.async();
    var sourceFileName = this.resourcePath;
    var plugin = this._compilation._ngToolsWebpackPluginInstance;
    // We must verify that AotPlugin is an instance of the right class.
    if (plugin && plugin instanceof plugin_1.AotPlugin) {
        var refactor_2 = new refactor_1.TypeScriptFileRefactor(sourceFileName, plugin.compilerHost, plugin.program);
        Promise.resolve()
            .then(function () {
            if (!plugin.skipCodeGeneration) {
                return Promise.resolve()
                    .then(function () { return _removeDecorators(refactor_2); })
                    .then(function () { return _replaceBootstrap(plugin, refactor_2); });
            }
            else {
                return Promise.resolve()
                    .then(function () { return _replaceResources(refactor_2); })
                    .then(function () { return _removeModuleId(refactor_2); });
            }
        })
            .then(function () {
            if (plugin.typeCheck) {
                // Check all diagnostics from this and reverse dependencies also.
                if (!plugin.firstRun) {
                    _diagnoseDeps(_this._module.reasons, plugin, new Set());
                }
                // We do this here because it will throw on error, resulting in rebuilding this file
                // the next time around if it changes.
                plugin.diagnose(sourceFileName);
            }
        })
            .then(function () {
            // Force a few compiler options to make sure we get the result we want.
            var compilerOptions = Object.assign({}, plugin.compilerOptions, {
                inlineSources: true,
                inlineSourceMap: false,
                sourceRoot: plugin.basePath
            });
            var result = refactor_2.transpile(compilerOptions);
            cb(null, result.outputText, result.sourceMap);
        })
            .catch(function (err) { return cb(err); });
    }
    else {
        var options = loaderUtils.parseQuery(this.query);
        var tsConfigPath = options.tsConfigPath;
        var tsConfig = ts.readConfigFile(tsConfigPath, ts.sys.readFile);
        if (tsConfig.error) {
            throw tsConfig.error;
        }
        var compilerOptions = tsConfig.config.compilerOptions;
        for (var _i = 0, _a = Object.keys(options); _i < _a.length; _i++) {
            var key = _a[_i];
            if (key == 'tsConfigPath') {
                continue;
            }
            compilerOptions[key] = options[key];
        }
        var compilerHost = ts.createCompilerHost(compilerOptions);
        var refactor = new refactor_1.TypeScriptFileRefactor(sourceFileName, compilerHost);
        _replaceResources(refactor);
        var result = refactor.transpile(compilerOptions);
        // Webpack is going to take care of this.
        result.outputText = result.outputText.replace(/^\/\/# sourceMappingURL=[^\r\n]*/gm, '');
        cb(null, result.outputText, result.sourceMap);
    }
}
exports.ngcLoader = ngcLoader;
//# sourceMappingURL=/Users/hansl/Sources/angular-cli/packages/@ngtools/webpack/src/loader.js.map